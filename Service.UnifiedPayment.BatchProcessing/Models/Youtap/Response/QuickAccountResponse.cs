// Generated by https://quicktype.io

namespace QuickType
{
    using System;
    using System.Collections.Generic;

    using System.Globalization;
    using Newtonsoft.Json;
    using Newtonsoft.Json.Converters;

    public partial class QuickAccount
    {
        [JsonProperty("clientType")]
        public ClientType ClientType { get; set; }

        [JsonProperty("customerId")]
        public long CustomerId { get; set; }

        [JsonProperty("accountId")]
        public long AccountId { get; set; }

        [JsonProperty("accountName")]
        public string AccountName { get; set; }

        [JsonProperty("suspended")]
        public bool Suspended { get; set; }

        [JsonProperty("fraudLocked")]
        public bool FraudLocked { get; set; }

        [JsonProperty("accountStatus")]
        public AccountStatus AccountStatus { get; set; }

        [JsonProperty("accountStatusId")]
        public long AccountStatusId { get; set; }

        [JsonProperty("default")]
        public bool Default { get; set; }

        [JsonProperty("accountType")]
        public AccountType AccountType { get; set; }

        [JsonProperty("accountTypeId")]
        public long? AccountTypeId { get; set; }

        [JsonProperty("accountColor")]
        public string AccountColor { get; set; }

        [JsonProperty("walletType")]
        public string WalletType { get; set; }

        [JsonProperty("walletTypeId")]
        public long? WalletTypeId { get; set; }

        [JsonProperty("createdDate")]
        public long CreatedDate { get; set; }

        [JsonProperty("balances")]
        public Balance[] Balances { get; set; }
    }

    public partial class Balance
    {
        [JsonProperty("balanceId")]
        public long BalanceId { get; set; }

        [JsonProperty("balance")]
        public double BalanceBalance { get; set; }

        [JsonProperty("balanceType")]
        public BalanceType BalanceType { get; set; }

        [JsonProperty("balanceTypeId")]
        public long BalanceTypeId { get; set; }

        [JsonProperty("metric")]
        public Metric Metric { get; set; }
    }

    public partial class Metric
    {
        [JsonProperty("unitLongName")]
        public UnitLongName UnitLongName { get; set; }

        [JsonProperty("unitShortName")]
        public UnitShortName UnitShortName { get; set; }

        [JsonProperty("displayString")]
        public DisplayString DisplayString { get; set; }

        [JsonProperty("displayDivisor")]
        public long DisplayDivisor { get; set; }

        [JsonProperty("displayUnitDelimiter")]
        public DisplayUnitDelimiter DisplayUnitDelimiter { get; set; }

        [JsonProperty("displayUnitMinorDelimiter")]
        public DisplayUnitMinorDelimiter DisplayUnitMinorDelimiter { get; set; }

        [JsonProperty("displayFormatter")]
        public DisplayFormatter DisplayFormatter { get; set; }
    }

    public enum AccountStatus { Active, ActiveUsable };

    public enum AccountType { BillerAccount, Savings, WalletMobAccount };

    public enum BalanceType { Cash, CashMmk, Emoney, EmoneyMmk };

    public enum DisplayFormatter { The000 };

    public enum DisplayString { Afn, Empty, K, N, Nz };

    public enum DisplayUnitDelimiter { Empty };

    public enum DisplayUnitMinorDelimiter { Empty };

    public enum UnitLongName { AfghanAfghani, BurmeseKyat, NewZealandDollar, NzDollars, UsDollars };

    public enum UnitShortName { Afn, Mmk, Nzd, Usd };

    public enum ClientType { Fineract, Yts };

    public partial class QuickAccount
    {
        public static QuickAccount[] FromJson(string json) => JsonConvert.DeserializeObject<QuickAccount[]>(json, QuickType.Converter.Settings);
    }

    internal class AccountStatusConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccountStatus) || t == typeof(AccountStatus?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Active":
                    return AccountStatus.Active;
                case "Active - usable":
                    return AccountStatus.ActiveUsable;
            }
            throw new Exception("Cannot unmarshal type AccountStatus");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AccountStatus)untypedValue;
            switch (value)
            {
                case AccountStatus.Active:
                    serializer.Serialize(writer, "Active");
                    return;
                case AccountStatus.ActiveUsable:
                    serializer.Serialize(writer, "Active - usable");
                    return;
            }
            throw new Exception("Cannot marshal type AccountStatus");
        }

        public static readonly AccountStatusConverter Singleton = new AccountStatusConverter();
    }

    internal class AccountTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(AccountType) || t == typeof(AccountType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Biller Account":
                    return AccountType.BillerAccount;
                case "Savings":
                    return AccountType.Savings;
                case "Wallet Mob Account":
                    return AccountType.WalletMobAccount;
            }
            throw new Exception("Cannot unmarshal type AccountType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (AccountType)untypedValue;
            switch (value)
            {
                case AccountType.BillerAccount:
                    serializer.Serialize(writer, "Biller Account");
                    return;
                case AccountType.Savings:
                    serializer.Serialize(writer, "Savings");
                    return;
                case AccountType.WalletMobAccount:
                    serializer.Serialize(writer, "Wallet Mob Account");
                    return;
            }
            throw new Exception("Cannot marshal type AccountType");
        }

        public static readonly AccountTypeConverter Singleton = new AccountTypeConverter();
    }

    internal class BalanceTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(BalanceType) || t == typeof(BalanceType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "CASH":
                    return BalanceType.Cash;
                case "CASH_MMK":
                    return BalanceType.CashMmk;
                case "EMONEY":
                    return BalanceType.Emoney;
                case "EMONEY_MMK":
                    return BalanceType.EmoneyMmk;
            }
            throw new Exception("Cannot unmarshal type BalanceType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (BalanceType)untypedValue;
            switch (value)
            {
                case BalanceType.Cash:
                    serializer.Serialize(writer, "CASH");
                    return;
                case BalanceType.CashMmk:
                    serializer.Serialize(writer, "CASH_MMK");
                    return;
                case BalanceType.Emoney:
                    serializer.Serialize(writer, "EMONEY");
                    return;
                case BalanceType.EmoneyMmk:
                    serializer.Serialize(writer, "EMONEY_MMK");
                    return;
            }
            throw new Exception("Cannot marshal type BalanceType");
        }

        public static readonly BalanceTypeConverter Singleton = new BalanceTypeConverter();
    }

    internal class DisplayFormatterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayFormatter) || t == typeof(DisplayFormatter?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == "#,##0.00")
            {
                return DisplayFormatter.The000;
            }
            throw new Exception("Cannot unmarshal type DisplayFormatter");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayFormatter)untypedValue;
            if (value == DisplayFormatter.The000)
            {
                serializer.Serialize(writer, "#,##0.00");
                return;
            }
            throw new Exception("Cannot marshal type DisplayFormatter");
        }

        public static readonly DisplayFormatterConverter Singleton = new DisplayFormatterConverter();
    }

    internal class DisplayStringConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayString) || t == typeof(DisplayString?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "$":
                    return DisplayString.Empty;
                case "AFN":
                    return DisplayString.Afn;
                case "K":
                    return DisplayString.K;
                case "N$":
                    return DisplayString.N;
                case "NZ$":
                    return DisplayString.Nz;
            }
            throw new Exception("Cannot unmarshal type DisplayString");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayString)untypedValue;
            switch (value)
            {
                case DisplayString.Empty:
                    serializer.Serialize(writer, "$");
                    return;
                case DisplayString.Afn:
                    serializer.Serialize(writer, "AFN");
                    return;
                case DisplayString.K:
                    serializer.Serialize(writer, "K");
                    return;
                case DisplayString.N:
                    serializer.Serialize(writer, "N$");
                    return;
                case DisplayString.Nz:
                    serializer.Serialize(writer, "NZ$");
                    return;
            }
            throw new Exception("Cannot marshal type DisplayString");
        }

        public static readonly DisplayStringConverter Singleton = new DisplayStringConverter();
    }

    internal class DisplayUnitDelimiterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayUnitDelimiter) || t == typeof(DisplayUnitDelimiter?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == ",")
            {
                return DisplayUnitDelimiter.Empty;
            }
            throw new Exception("Cannot unmarshal type DisplayUnitDelimiter");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayUnitDelimiter)untypedValue;
            if (value == DisplayUnitDelimiter.Empty)
            {
                serializer.Serialize(writer, ",");
                return;
            }
            throw new Exception("Cannot marshal type DisplayUnitDelimiter");
        }

        public static readonly DisplayUnitDelimiterConverter Singleton = new DisplayUnitDelimiterConverter();
    }

    internal class DisplayUnitMinorDelimiterConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(DisplayUnitMinorDelimiter) || t == typeof(DisplayUnitMinorDelimiter?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            if (value == ".")
            {
                return DisplayUnitMinorDelimiter.Empty;
            }
            throw new Exception("Cannot unmarshal type DisplayUnitMinorDelimiter");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (DisplayUnitMinorDelimiter)untypedValue;
            if (value == DisplayUnitMinorDelimiter.Empty)
            {
                serializer.Serialize(writer, ".");
                return;
            }
            throw new Exception("Cannot marshal type DisplayUnitMinorDelimiter");
        }

        public static readonly DisplayUnitMinorDelimiterConverter Singleton = new DisplayUnitMinorDelimiterConverter();
    }

    internal class UnitLongNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnitLongName) || t == typeof(UnitLongName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "Afghan afghani":
                    return UnitLongName.AfghanAfghani;
                case "Burmese Kyat":
                    return UnitLongName.BurmeseKyat;
                case "NZ Dollars":
                    return UnitLongName.NzDollars;
                case "New Zealand Dollar":
                    return UnitLongName.NewZealandDollar;
                case "US Dollars":
                    return UnitLongName.UsDollars;
            }
            throw new Exception("Cannot unmarshal type UnitLongName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnitLongName)untypedValue;
            switch (value)
            {
                case UnitLongName.AfghanAfghani:
                    serializer.Serialize(writer, "Afghan afghani");
                    return;
                case UnitLongName.BurmeseKyat:
                    serializer.Serialize(writer, "Burmese Kyat");
                    return;
                case UnitLongName.NzDollars:
                    serializer.Serialize(writer, "NZ Dollars");
                    return;
                case UnitLongName.NewZealandDollar:
                    serializer.Serialize(writer, "New Zealand Dollar");
                    return;
                case UnitLongName.UsDollars:
                    serializer.Serialize(writer, "US Dollars");
                    return;
            }
            throw new Exception("Cannot marshal type UnitLongName");
        }

        public static readonly UnitLongNameConverter Singleton = new UnitLongNameConverter();
    }

    internal class UnitShortNameConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(UnitShortName) || t == typeof(UnitShortName?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "AFN":
                    return UnitShortName.Afn;
                case "MMK":
                    return UnitShortName.Mmk;
                case "NZD":
                    return UnitShortName.Nzd;
                case "USD":
                    return UnitShortName.Usd;
            }
            throw new Exception("Cannot unmarshal type UnitShortName");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (UnitShortName)untypedValue;
            switch (value)
            {
                case UnitShortName.Afn:
                    serializer.Serialize(writer, "AFN");
                    return;
                case UnitShortName.Mmk:
                    serializer.Serialize(writer, "MMK");
                    return;
                case UnitShortName.Nzd:
                    serializer.Serialize(writer, "NZD");
                    return;
                case UnitShortName.Usd:
                    serializer.Serialize(writer, "USD");
                    return;
            }
            throw new Exception("Cannot marshal type UnitShortName");
        }

        public static readonly UnitShortNameConverter Singleton = new UnitShortNameConverter();
    }

    internal class ClientTypeConverter : JsonConverter
    {
        public override bool CanConvert(Type t) => t == typeof(ClientType) || t == typeof(ClientType?);

        public override object ReadJson(JsonReader reader, Type t, object existingValue, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;
            var value = serializer.Deserialize<string>(reader);
            switch (value)
            {
                case "FINERACT":
                    return ClientType.Fineract;
                case "YTS":
                    return ClientType.Yts;
            }
            throw new Exception("Cannot unmarshal type ClientType");
        }

        public override void WriteJson(JsonWriter writer, object untypedValue, JsonSerializer serializer)
        {
            if (untypedValue == null)
            {
                serializer.Serialize(writer, null);
                return;
            }
            var value = (ClientType)untypedValue;
            switch (value)
            {
                case ClientType.Fineract:
                    serializer.Serialize(writer, "FINERACT");
                    return;
                case ClientType.Yts:
                    serializer.Serialize(writer, "YTS");
                    return;
            }
            throw new Exception("Cannot marshal type ClientType");
        }

        public static readonly ClientTypeConverter Singleton = new ClientTypeConverter();
    }
}
